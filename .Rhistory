source('C:/Users/Greg Sanders/SkyDrive/Documents/R Scripts and Data SkyDrive/termination_study.R')
fit.2 <- glm (IsTerminated ~ log(UnmodifiedContractBaseAndAllOptionsValue)
,family=binomial(link="logit"
)
,na.action=na.exclude
)
fit.2 <- glm (IsTerminated ~ LogOfUnmodifiedContractBaseAndExercisedOptionsValue
,family=binomial(link="logit"
)
,na.action=na.exclude
)
display (fit.2)
attach(sample.SumofObligatedAmount)
fit.1 <- glm (IsTerminated ~ as.integer(SizeOfUnmodifiedContractBaseAndAll)
,family=binomial(link="logit")
)
display (fit.1)
fit.2 <- glm (IsTerminated ~ LogOfUnmodifiedContractBaseAndExercisedOptionsValue
,family=binomial(link="logit"
)
,na.action=na.exclude
)
display (fit.2)
invlogit (coef(fit.1)[1]+coef(fit.1)[2]*mean(as.integer(SizeOfUnmodifiedContractBaseAndAll))
)
invlogit (coef(fit.2)[1]+coef(fit.2)[2]*mean(as.integer(SizeOfUnmodifiedContractBaseAndAll)))
invlogit (coef(fit.2)[1]+coef(fit.2)[2]*mean(as.integer(SizeOfUnmodifiedContractBaseAndAll)))
fit.1 <- glm (IsTerminated ~ as.integer(SizeOfUnmodifiedContractBaseAndAll)
,family=binomial(link="logit")
)
display (fit.1)
#Evaluate the intercept at the mean of the ContractBaseAndExercisedOptionsValue values
invlogit (coef(fit.1)[1]+coef(fit.1)[2]*mean(as.integer(SizeOfUnmodifiedContractBaseAndAll)))
fit.2 <- glm (IsTerminated ~ LogOfUnmodifiedContractBaseAndExercisedOptionsValue
,family=binomial(link="logit"
)
,na.action=na.exclude
)
display (fit.2)
invlogit (coef(fit.2)[1]+coef(fit.2)[2]*mean(as.integer(SizeOfUnmodifiedContractBaseAndAll)))
plot(SizeOfUnmodifiedContractBaseAndAll,IsTerminated)
plot(SizeOfUnmodifiedContractBaseAndAll,IsTerminated)
??plot
?plot
plot(SizeOfUnmodifiedContractBaseAndAll,as.number(IsTerminated))
plot(as.integer(SizeOfUnmodifiedContractBaseAndAll),IsTerminated)
plot(as.integer(SizeOfUnmodifiedContractBaseAndAll),IsTerminated)
curve (invlogit (coef9fit.1)[1]+coef(fit.1)[2]*x), add=TRUE)
lot(as.integer(SizeOfUnmodifiedContractBaseAndAll),IsTerminated)
curve (invlogit (coef(fit.1)[1]+coef(fit.1)[2]*x), add=TRUE)
plot(as.integer(SizeOfUnmodifiedContractBaseAndAll),IsTerminated)
curve (invlogit (coef(fit.1)[1]+coef(fit.1)[2]*x), add=TRUE)
plot(LogOfUnmodifiedContractBaseAndExercisedOptionsValue,IsTerminated)
curve (invlogit (coef(fit.2)[1]+coef(fit.2)[2]*x), add=TRUE)
source('C:/Users/Greg Sanders/SkyDrive/Documents/R Scripts and Data SkyDrive/lookups.r')
source('C:/Users/Greg Sanders/SkyDrive/Documents/R Scripts and Data SkyDrive/lookups.r')
source('C:/Users/Greg Sanders/SkyDrive/Documents/R Scripts and Data SkyDrive/lookups.r')
source('C:/Users/Greg Sanders/SkyDrive/Documents/R Scripts and Data SkyDrive/lookups.r')
sample.SumofObligatedAmount$IsTerminated
source('C:/Users/Greg Sanders/SkyDrive/Documents/R Scripts and Data SkyDrive/termination_study.R')
fit.2 <- glm (as.integer(IsTerminated)-1 ~ LogOfUnmodifiedContractBaseAndExercisedOptionsValue
,family=binomial(link="logit"
)
,na.action=na.exclude
)
plot(LogOfUnmodifiedContractBaseAndExercisedOptionsValue,IsTerminated)
curve (invlogit (coef(fit.2)[1]+coef(fit.2)[2]*x), add=TRUE)
display (fit.2)
plot(LogOfUnmodifiedContractBaseAndExercisedOptionsValue,as.integer(IsTerminated)-1)
curve (invlogit (coef(fit.2)[1]+coef(fit.2)[2]*x), add=TRUE)
plot(LogOfUnmodifiedContractBaseAndExercisedOptionsValue,IsTerminated)
curve (invlogit (coef(fit.2)[1]+coef(fit.2)[2]*x+1), add=TRUE)
plot(as.integer(SizeOfUnmodifiedContractBaseAndAll),as.integer(IsTerminated)-1)
curve (invlogit (coef(fit.1)[1]+coef(fit.1)[2]*x), add=TRUE)
attach(sample.SumofObligatedAmount)
fit.1 <- glm (IsTerminated ~ as.integer(SizeOfUnmodifiedContractBaseAndAll)
,family=binomial(link="logit")
)
display (fit.1)
#Evaluate the intercept at the mean of the ContractBaseAndExercisedOptionsValue values
invlogit (coef(fit.1)[1]+coef(fit.1)[2]*mean(as.integer(SizeOfUnmodifiedContractBaseAndAll)))
plot(as.integer(SizeOfUnmodifiedContractBaseAndAll),as.integer(IsTerminated)-1)
curve (invlogit (coef(fit.1)[1]+coef(fit.1)[2]*x), add=TRUE)
plot(SizeOfUnmodifiedContractBaseAndAll,as.integer(IsTerminated)-1)
curve (invlogit (coef(fit.1)[1]+coef(fit.1)[2]*x), add=TRUE)
plot(SizeOfUnmodifiedContractBaseAndAll,IsTerminated))
curve (invlogit (coef(fit.1)[1]+coef(fit.1)[2]*x), add=TRUE)
plot(SizeOfUnmodifiedContractBaseAndAll,IsTerminated)
plot(SizeOfUnmodifiedContractBaseAndAll,as.integer(IsTerminated)-1)
curve (invlogit (coef(fit.1)[1]+coef(fit.1)[2]*x), add=TRUE)
fit.1 <- glm (IsTerminated ~ as.integer(SizeOfUnmodifiedContractBaseAndAll)
,family=binomial(link="logit")
)
display (fit.1)
#Evaluate the intercept at the mean of the ContractBaseAndExercisedOptionsValue values
invlogit (coef(fit.1)[1]+coef(fit.1)[2]*mean(as.integer(SizeOfUnmodifiedContractBaseAndAll)))
plot(SizeOfUnmodifiedContractBaseAndAll,as.integer(IsTerminated)-1)
curve (invlogit (coef(fit.1)[1]+coef(fit.1)[2]*x), add=TRUE)
fit.2 <- glm (IsTerminated ~ LogOfUnmodifiedContractBaseAndExercisedOptionsValue
,family=binomial(link="logit"
)
,na.action=na.exclude
)
plot(LogOfUnmodifiedContractBaseAndExercisedOptionsValue,as.integer(IsTerminated)-1)
curve (invlogit (coef(fit.2)[1]+coef(fit.2)[2]*x), add=TRUE)
display (fit.2)
invlogit (coef(fit.2)[1]+coef(fit.2)[2]*mean(as.integer(SizeOfUnmodifiedContractBaseAndAll)))
fit.length <- glm (IsTerminated ~ CurrentMonths
,family=binomial(link="logit"
)
,na.action=na.exclude
)
plot(CurrentMonths,as.integer(IsTerminated)-1)
curve (invlogit (coef(fit.length)[1]+coef(fit.length)[2]*x), add=TRUE)
display (fit.length)
invlogit (coef(fit.length)[1]+coef(fit.length)[2]*mean(as.integer(SizeOfUnmodifiedContractBaseAndAll)))
weirdduration<-subset(sample.SumofObligatedAmount,CurrentMonths>120)
View(weirdduration)
cbind(weirdduration$MinOfEffectiveDate,weirdduration$LastCurrentCompletionDate)
weirdduration<-subset(sample.SumofObligatedAmount,CurrentMonths>150)
cbind(weirdduration$MinOfEffectiveDate,weirdduration$LastCurrentCompletionDate)
weirdduration<-subset(sample.SumofObligatedAmount,CurrentMonths>160)
weirdduration<-subset(sample.SumofObligatedAmount,CurrentMonths>160)
cbind(weirdduration$MinOfEffectiveDate,weirdduration$LastCurrentCompletionDate)
cbind(weirdduration$MinOfEffectiveDate,weirdduration$LastCurrentCompletionDate,weirdduration$MaxOfEffectiveDate)
source('C:/Users/Greg Sanders/SkyDrive/Documents/R Scripts and Data SkyDrive/lookups.r')
source('~/.active-rstudio-document')
weirdduration
cbind(weirdduration$MinOfEffectiveDate,weirdduration$LastCurrentCompletionDate,weirdduration$MaxOfEffectiveDate)
cbind(weirdduration$MinOfEffectiveDate,weirdduration$LastCurrentCompletionDate,weirdduration$MaxOfEffectiveDate,weirdduration$CurrentMonths,weirdduration$IsClosed)
cbind(weirdduration$MinOfEffectiveDate,weirdduration$LastCurrentCompletionDate,weirdduration$MaxOfEffectiveDate,weirdduration$CurrentMonths,weirdduration$IsClosed,weirdduration$IsTerminated)
weirdduration<-subset(sample.SumofObligatedAmount,CurrentMonths>182)
cbind(weirdduration$MinOfEffectiveDate,weirdduration$LastCurrentCompletionDate,weirdduration$MaxOfEffectiveDate,weirdduration$CurrentMonths,weirdduration$IsClosed,weirdduration$IsTerminated)
source('C:/Users/Greg Sanders/SkyDrive/Documents/R Scripts and Data SkyDrive/lookups.r')
source('~/.active-rstudio-document')
cbind(weirdduration$MinOfEffectiveDate,weirdduration$LastCurrentCompletionDate,weirdduration$MaxOfEffectiveDate,weirdduration$CurrentMonths,weirdduration$IsClosed,weirdduration$IsTerminated)
source('C:/Users/Greg Sanders/SkyDrive/Documents/R Scripts and Data SkyDrive/lookups.r')
source('C:/Users/Greg Sanders/SkyDrive/Documents/R Scripts and Data SkyDrive/termination_study.R')
ls()
ls()
source('C:/Users/Greg Sanders/SkyDrive/Documents/R Scripts and Data SkyDrive/lookups.r')
source('C:/Users/Greg Sanders/SkyDrive/Documents/R Scripts and Data SkyDrive/termination_study.R')
ls()
strptime(VAR.df[VAR.df$IsClosed=="Closed"]$MaxOfEffectiveDate,"%Y-%m-%d")
VAR.df[VAR.df$IsClosed=="Closed"]
VAR.df$IsClosed=="Closed"
VAR.df[VAR.df$IsClosed=="Closed"]
source('C:/Users/Greg Sanders/SkyDrive/Documents/R Scripts and Data SkyDrive/lookups.r')
source('C:/Users/Greg Sanders/SkyDrive/Documents/R Scripts and Data SkyDrive/termination_study.R')
cbind(weirdduration$MinOfEffectiveDate,weirdduration$LastCurrentCompletionDate,weirdduration$MaxOfEffectiveDate,weirdduration$CurrentMonths,weirdduration$IsClosed,weirdduration$IsTerminated)
source('C:/Users/Greg Sanders/SkyDrive/Documents/R Scripts and Data SkyDrive/create_SQL_figures_split.R')
install.package("kernsmooth")
package.install("kernsmooth")
install.packages("KernSmooth")
??KernSmooth
KernSmooth
?KernSmooth
??KernSmooth
library(KernSmooth)
require(KernSmooth)
install.packages("devtools")
library("devtools", lib.loc="~/R/win-library/3.0")
find_rtools()
?addna
?addNA
?qnorm
qnorm(75,0,1)
qnorm(.75,0,1,lower.tail=TRUE)
qnorm(.95,0,1,lower.tail=TRUE)
qnorm(.95,1100,50,lower.tail=TRUE)
qnorm(.95,1100,75,lower.tail=TRUE)
qnorm(.95,1100,75,lower.tail=FALSE)
qnorm(.95,1100,75,lower.tail=TRUE)
75^2/100
qnorm(.95,1100,75^2/100,lower.tail=TRUE)
qnorm(.95,1100,sqrt(75^2/100),lower.tail=TRUE)
?qbinom
0.5^5
0.5^5*7
0.5^5*6
??poisson
ppois(10, lambda = 5*3)
answer<-dataframe(id=c(1,2,3),nobs(117,1024,243))
answer
answer<-data.frame(id=c(1,2,3),nobs(117,1024,243))
answer
answer<-data.frame(id=c(1,2,3),nobs(117,1024,243))
answer<-data.frame(id=c(1,2,3),nobs=c(117,1024,243))
answer
seq_along(answer)
??seq
length(answer)
nrow(answer)
testmatrix<-matrix(5,6,7)
testmatrix<-rnorm(5*6*7)
testmatrix
View(testmatrix)
??matrix
?matrix
dim(x)<-c(5,6,7)
dim(testmatrix)<-c(5,6,7)
testmatrix
o<-makecachematrix(testmatrix)
## Created: 2014/0115
## Matrix inversion is usually a costly computation and there may be some
## benefit to caching the inverse of a matrix rather than computing it repeatedly.
## Through lexical scoping, the CachedMatrix essentially acts as an object for
## storage of a matrix.
## There are two direct functions. makeCacheMatrix which is used to initialize
## the matrix and cacheSolve which is used to calculate the inverse of 'x'
## I've actually stored the calculating functions entirely within makeCacheMatrix
## and only use cacheSolve as a wrapper for getinverse
## This function creates a special "matrix" object that can cache its inverse.
# It returns four functions.
# set, which can be used to assign a new matrix value.
# get, which returns the current matrix value.
# setinverse which caches the inverse value
# and get inverse which returns the inverse, calling setinverse if it's null
makeCacheMatrix <- function(x = matrix()) {
i <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(solve) i <<- solve
getinverse <- function(){ i
if(is.null(i)) setinverse
i
}
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
}
## Created: 2014/0115
## Matrix inversion is usually a costly computation and there may be some
## benefit to caching the inverse of a matrix rather than computing it repeatedly.
## Through lexical scoping, the CachedMatrix essentially acts as an object for
## storage of a matrix.
## There are two direct functions. makeCacheMatrix which is used to initialize
## the matrix and cacheSolve which is used to calculate the inverse of 'x'
## I've actually stored the calculating functions entirely within makeCacheMatrix
## and only use cacheSolve as a wrapper for getinverse
## This function creates a special "matrix" object that can cache its inverse.
# It returns four functions.
# set, which can be used to assign a new matrix value.
# get, which returns the current matrix value.
# setinverse which caches the inverse value
# and get inverse which returns the inverse, calling setinverse if it's null
makeCacheMatrix <- function(x = matrix()) {
i <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(solve) i <<- solve
getinverse <- function(){ i
if(is.null(i)) setinverse
i
}
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
x$getinverse
}
o<-makecachematrix(testmatrix)
o<-makeCacheMatrix(testmatrix)
o<-makeCacheMatrix(testmatrix)
source('~/.active-rstudio-document')
o<-makeCacheMatrix(testmatrix)
o
o$getinverse
o$getinverse()
o$get()
source('~/Development/ProgrammingAssignment2/cachematrix.R')
o$getinverse()
?solve
source('~/Development/ProgrammingAssignment2/cachematrix.R')
testmatrix<-rnorm(5*5*5)
dim(testmatrix)<-c(5,5,5
)
o$setmatrix(testmatrix)
o$set(testmatrix)
o$getinverse()
dim(testmatrix)<-c(5,5,5)
testmatrix
o$get()
o$getinverse()
solve(testmatrix)
dims(a)
dim(a)
dim(testmatrix)
testmatrix<-rnorm(5*5)
dim(testmatrix)<-c(5,5)
o$set(testmatrix)
o<-makeCacheMatrix(testmatrix)
o$getinverse()
cachesSolve(o)
cacheSolve(o)
cacheSolve(o)
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
x$getinverse()
}
cacheSolve(o)
source('~/Development/ProgrammingAssignment2/cachematrix.R')
source('~/Development/ProgrammingAssignment2/cachematrix.R')
source('~/Development/ProgrammingAssignment2/cachematrix.R')
# Here's a sample implementation
testmatrix<-rnorm(5*5)
dim(testmatrix)<-c(5,5)
o<-makeCacheMatrix(testmatrix)
o$setinverse()
o$getinverse()
testmatrix2<-rnorm(100*100)
dim(testmatrix)<-c(100,100)
o$set(testmatrix2)
o$setinverse()
o$getinverse()
testmatrix<-rnorm(100*100)
dim(testmatrix)<-c(100,100)
o$set(testmatrix)
o$setinverse()
o$getinverse()
testmatrix<-rnorm(10*10)
dim(testmatrix)<-c(10,10)
o$set(testmatrix)
o$getinverse()
?runif
?rexp
lambda<-0.2
rexp(n=40,rate=lambda)
lambda<-0.2
hist(rexp(n=40,rate=lambda))
rexpsim<-matrix(rexp(n=n*nosim,rate=lambda),nosim)
nosim<-40
n<-1,000
n<-1000
hist(rexp(n=n,rate=lambda))
rexpsim<-matrix(rexp(n=n*nosim,rate=lambda),nosim)
rexpsim<-matrix(rexp(n=n*nosim,rate=lambda),nosim)
rexpsim
?apply
apply(rexpsim,1,mean)
#This function calculate the means of each of the forty simluations.
expmean<-apply(rexpsim,1,mean)
#We then plot these means.
hist(expmean)
?hist
#This function calculate the means of each of the forty simluations.
expmean<-apply(rexpsim,1,mean)
#We then plot these means and calculate the mean of the means.
hist(expmean
,main=paste("The means of ",n" different ",nosim,"element\nexponential distribution samples\n(lamba=",lambda)
,xlab="The sample mean (theoretical mean = 5)"
)
meanofmeans<-mean(expmean)
0
paste("The means of ",n" different ",nosim,"element\nexponential distribution samples\n(lamba=",lambda)
hist(expmean
,main=paste("The means of ",n," different ",nosim,
"element\nexponential distribution samples\n(lamba=",lambda)
,xlab="The sample mean (theoretical mean = 5)"
)+abline(v=theomean,col="red")
theomean<-1/lambda
hist(expmean
,main=paste("The means of ",n," different ",nosim,
"element\nexponential distribution samples\n(lamba=",lambda)
,xlab="The sample mean (theoretical mean = 5)"
)+abline(v=theomean,col="red")
n
nosim
lambda
paste("The means of ",n," different ",nosim,
"element\nexponential distribution samples\n(lamba=",lambda)
hist(expmean
,main=paste("The means of ",n," different ",nosim,
"element\nexponential distribution samples\n(lamba=",lambda)
,xlab="The sample mean (theoretical mean = 5)"
)
abline(v=theomean,col="red")
hist(expmean
,main=paste("The means of ",n," different ",nosim,
"element\nexponential distribution samples\n(lamba=",lambda)
,xlab="The sample mean (theoretical mean = 5)"
)+abline(v=theomean,col="red")
?hist
?rseed
?norm
?rnorm
meanse
sqrt(theovar)/sqrt(nosim)
sqrt(5)/sqrt(40)
?density
#Second we again plot the variances
plot(density(expvar)
,main=paste("The distribution variances compared to the normal curve")
,xlab=paste("The sample variance (theoretical mean = ",theovar,")",sep="")
)
#Then we calculate the standard error of the variance
varse<-sd(expvar)
#Then we create a density normal curve with the values mentioned above
varnorm<-rnorm(1000,mean=meanofvars,sd=varse)
#Then we plot the density curve
lines(density(varnorm),col="blue")
meanse
?plot
?lines
?dim
install.packages("pdflatex")
?dplyr
source('C:/Users/Greg Sanders/SkyDrive/Documents/R Scripts and Data SkyDrive/helper.r')
source('C:/Users/Greg Sanders/SkyDrive/Documents/R Scripts and Data SkyDrive/helper.r')
require(ggplot2)
require(stringr)
require(plyr)
require(Hmisc)
require(lubridate)
options(error=recover)
# setwd("K:\\Development\\Fixed-price")
# setwd("C:\\Users\\Greg Sanders\\Documents\\Development\\Fixed-price")
Path<-"K:\\2007-01 PROFESSIONAL SERVICES\\R scripts and data\\"
# Path<-"C:\\Users\\Greg Sanders\\SkyDrive\\Documents\\R Scripts and Data SkyDrive\\"
source(paste(Path,"lookups.r",sep=""))
require(ggplot2)
require(stringr)
require(plyr)
require(Hmisc)
require(lubridate)
options(error=recover)
# setwd("K:\\Development\\Fixed-price")
# setwd("C:\\Users\\Greg Sanders\\Documents\\Development\\Fixed-price")
# Path<-"K:\\2007-01 PROFESSIONAL SERVICES\\R scripts and data\\"
Path<-"C:\\Users\\Greg Sanders\\SkyDrive\\Documents\\R Scripts and Data SkyDrive\\"
source(paste(Path,"lookups.r",sep=""))
RawContract  <- read.csv(
paste(Path,"data\\defense_contract_SP_ContractSampleCriteriaDetailsCustomer.csv", sep = ""),
header = TRUE, sep = ",", dec = ".", strip.white = TRUE,
na.strings = c("NULL","NA",""),
stringsAsFactors = TRUE
)
?order
source('~/Development/JointDevelopment/JointDevSurveyGraphs_Revised.R', echo=TRUE)
?geom_abline
?geom_ABline
source('~/Development/JointDevelopment/JointDevSurveyGraphs_Revised.R', echo=TRUE)
install.packages("xlsx")
source('~/Development/JointDevelopment/JointDevSurveyGraphs_Revised.R', echo=TRUE)
install.packages("data.table")
source('~/Development/JointDevelopment/JointDevSurveyGraphs_Revised.R', echo=TRUE)
install.packages("dplyr")
source('~/Development/JointDevelopment/JointDevSurveyGraphs_Revised.R', echo=TRUE)
install.packages("tidyr")
source('~/Development/JointDevelopment/JointDevSurveyGraphs_Revised.R', echo=TRUE)
require(Hmisc)
require(texreg)
require(plm)
require(ggplot2)
require(reshape2)
require(plyr)
require(quantmod)
#Your working directory here!
# setwd("K:/Development/Europe") #Your working directory here!
#setwd("C:/Users/Greg Sanders/Documents/Development/Europe")
# setwd("C:/Users/scohen/My Documents/Europe/Git/Europe")
source("EuropeInput.R")
options(error=recover)
options(warn=1)
require(Hmisc)
require(texreg)
require(plm)
require(ggplot2)
require(reshape2)
require(plyr)
require(quantmod)
#Your working directory here!
# setwd("K:/Development/Europe") #Your working directory here!
setwd("C:/Users/Greg Sanders/Documents/Development/Europe")
# setwd("C:/Users/scohen/My Documents/Europe/Git/Europe")
source("EuropeInput.R")
EuropeOmnibus <- CompilePubOpDataOmnibus()
require(Hmisc)
install.packages("Hmisc")
require(Hmisc)
require(texreg)
require(plm)
require(ggplot2)
require(reshape2)
require(plyr)
require(quantmod)
install.packages("quantmod")
require(texreg)
require(plm)
require(ggplot2)
require(reshape2)
require(plyr)
require(quantmod)
install.packages("plm")
require(texreg)
require(plm)
require(ggplot2)
require(reshape2)
require(plyr)
require(quantmod)
install.packages("texreg")
